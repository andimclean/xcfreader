<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HA XCF Image Card Demo</title>
  <script type="module" src="/packages/ha-xcfimage-card/dist/ha-xcfimage-card.js"></script>
  <style>
    :root {
      --ha-card-background: #ffffff;
      --card-background-color: #ffffff;
      --ha-card-border-radius: 12px;
      --ha-card-box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      --primary-text-color: #212121;
      --secondary-text-color: #727272;
      --error-color: #ff5252;
    }

    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }

    .demo-container {
      max-width: 800px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .controls {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .controls h2 {
      margin-top: 0;
    }

    .entity-control {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 0;
      border-bottom: 1px solid #eee;
    }

    .entity-control:last-child {
      border-bottom: none;
    }

    .entity-name {
      flex: 1;
      font-weight: 500;
    }

    .entity-state {
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.9em;
      font-weight: 500;
    }

    .entity-state.on {
      background: #4caf50;
      color: white;
    }

    .entity-state.off {
      background: #9e9e9e;
      color: white;
    }

    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    button:hover {
      opacity: 0.9;
    }

    .toggle-btn {
      background: #2196f3;
      color: white;
    }

    .info {
      background: #e3f2fd;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
      color: #1565c0;
    }

    .xcf-select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 16px;
    }

    #entityControls {
      max-height: 300px;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 8px;
      margin-top: 12px;
    }

    #entityControls::-webkit-scrollbar {
      width: 8px;
    }

    #entityControls::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    #entityControls::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }

    #entityControls::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div class="demo-container">
    <h1>Home Assistant XCF Image Card Demo</h1>

    <div class="controls">
      <h2>Demo Controls</h2>
      <div class="info">
        Toggle the switches below to simulate Home Assistant entity states.
        The XCF image layers will update in real-time.
      </div>

      <label>
        <strong>XCF File:</strong>
        <select class="xcf-select" id="xcfSelect">
          <option value="/example-xcf/multi.xcf">multi.xcf (3 layers)</option>
          <option value="/example-xcf/map1.xcf">map1.xcf</option>
          <option value="/example-xcf/FirstFloor.xcf">FirstFloor.xcf</option>
          <option value="/example-xcf/GroundFloor.xcf">GroundFloor.xcf (floating sel)</option>
          <option value="/example-xcf/192608-nhl-marlow.xcf">192608-nhl-marlow.xcf (1.5 MB)</option>
          <option value="/example-xcf/icon.xcf">icon.xcf</option>
          <option value="/example-xcf/float32.xcf">float32.xcf (32-bit float)</option>
          <option value="/example-xcf/grey.xcf">grey.xcf (grayscale)</option>
          <option value="/example-xcf/indexed.xcf">indexed.xcf (paletted)</option>
          <option value="/example-xcf/fullColour.xcf">fullColour.xcf (RGB v011)</option>
          <option value="/example-xcf/int32.xcf">int32.xcf (32-bit int)</option>
          <option value="/example-xcf/single.xcf">single.xcf</option>
          <option value="/example-xcf/text.xcf">text.xcf</option>
          <option value="/example-xcf/empty.xcf">empty.xcf</option>
          <option value="/example-xcf/boardpieces.xcf">boardpieces.xcf (game sprites)</option>
          <option value="/example-xcf/currentpieces.xcf">currentpieces.xcf (game sprites)</option>
          <option value="/example-xcf/wallpieces.xcf">wallpieces.xcf (game sprites)</option>
          <option value="/example-xcf/maingradient.xcf">maingradient.xcf (duplicate names)</option>
          <option value="/example-xcf/pipe.xcf">pipe.xcf (indexed 256)</option>
        </select>
      </label>

      <div id="entityControls"></div>
    </div>

    <ha-xcfimage-card id="card"></ha-xcfimage-card>

    <div class="controls">
      <h2>Entity Overlays Demo</h2>
      <div class="info">
        This demo shows entity overlays positioned at layer locations.
        The overlays are placed at layer positions (top-left, center, top-right) but the layers themselves are NOT shown.
        Click the overlays to toggle the entities.
      </div>
      <div id="overlayEntityControls"></div>
    </div>

    <ha-xcfimage-card id="overlayCard"></ha-xcfimage-card>
  </div>

  <script>
    // Mock Home Assistant object
    const mockHass = {
      states: {
        'light.layer_base': { state: 'on', attributes: {}, last_changed: '', last_updated: '' },
        'light.layer_shaded': { state: 'off', attributes: {}, last_changed: '', last_updated: '' },
        'light.layer_red1': { state: 'off', attributes: {}, last_changed: '', last_updated: '' },
        'light.layer_red2': { state: 'off', attributes: {}, last_changed: '', last_updated: '' },
      },
      callService: async () => {},
    };

    let entities = [
      { entity: 'light.layer_base', name: 'Base (grayscale)', layer: 7, initialState: 'on' },
      { entity: 'light.layer_shaded', name: 'Shaded', layer: 6, initialState: 'off' },
      { entity: 'light.layer_red1', name: 'Red Corner 1', layer: 1, initialState: 'off' },
      { entity: 'light.layer_red2', name: 'Red Corner 2', layer: 2, initialState: 'off' },
    ];

    // Setup card
    const card = document.getElementById('card');
    const xcfSelect = document.getElementById('xcfSelect');

    function updateCardConfig() {
      console.log('Updating card config...');
      card.setConfig({
        type: 'custom:ha-xcfimage-card',
        title: 'Demo XCF Image',
        xcf_url: xcfSelect.value,
        entity_layers: entities.map(e => ({
          entity: e.entity,
          layer: e.layer,
          state_on: 'on'
        })),
        default_visible: [],
      });
      card.hass = mockHass;

      // Debug: Check what's in the shadow DOM
      setTimeout(() => {
        const xcfElement = card.shadowRoot?.querySelector('gpp-xcfimage');
        console.log('XCF Element:', xcfElement);
        console.log('Visible attribute:', xcfElement?.getAttribute('visible'));
        console.log('Current entity states:', mockHass.states);
      }, 100);
    }

    xcfSelect.addEventListener('change', updateCardConfig);

    // Function to generate entities from layer data
    function generateEntitiesFromLayers(layerTree) {
      const layerList = [];

      function traverse(node) {
        if (node.index !== undefined && !node.isGroup) {
          layerList.push({
            index: node.index,
            name: node.name || `Layer ${node.index}`,
            isVisible: node.isVisible
          });
        }
        if (node.children) {
          node.children.forEach(child => traverse(child));
        }
      }

      traverse(layerTree);
      return layerList;
    }

    // Function to create entity controls
    function createEntityControls() {
      const controlsDiv = document.getElementById('entityControls');
      controlsDiv.innerHTML = '';

      entities.forEach(entity => {
        // Ensure entity exists in mockHass, respecting initial visibility
        if (!mockHass.states[entity.entity]) {
          mockHass.states[entity.entity] = {
            state: entity.initialState || 'off',
            attributes: {},
            last_changed: '',
            last_updated: ''
          };
        }

        const div = document.createElement('div');
        div.className = 'entity-control';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'entity-name';
        nameSpan.textContent = entity.name;

        const stateSpan = document.createElement('span');
        stateSpan.className = 'entity-state ' + mockHass.states[entity.entity].state;
        stateSpan.textContent = mockHass.states[entity.entity].state.toUpperCase();

        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-btn';
        toggleBtn.textContent = 'Toggle';
        toggleBtn.onclick = () => {
          const currentState = mockHass.states[entity.entity].state;
          const newState = currentState === 'on' ? 'off' : 'on';
          console.log(`Toggle ${entity.entity}: ${currentState} -> ${newState}`);
          mockHass.states[entity.entity].state = newState;
          stateSpan.textContent = newState.toUpperCase();
          stateSpan.className = 'entity-state ' + newState;
          card.hass = { ...mockHass }; // Trigger update

          // Debug: Check visible attribute after update
          setTimeout(() => {
            const xcfElement = card.shadowRoot?.querySelector('gpp-xcfimage');
            console.log('After toggle - Visible attribute:', xcfElement?.getAttribute('visible'));
            console.log('XCF element src:', xcfElement?.getAttribute('src'));
            console.log('XCF element canvas:', xcfElement?.shadowRoot?.querySelector('canvas'));

            // Try to force re-render by checking if element exists
            if (xcfElement) {
              console.log('XCF element tag:', xcfElement.tagName);
              console.log('XCF element constructor:', xcfElement.constructor.name);
            }
          }, 100);
        };

        div.appendChild(nameSpan);
        div.appendChild(stateSpan);
        div.appendChild(toggleBtn);
        controlsDiv.appendChild(div);
      });
    }

    // Track the current XCF file to detect actual changes
    let currentXcfUrl = '';

    // Listen for XCF loaded event to regenerate controls
    card.addEventListener('xcf-loaded', (event) => {
      console.log('XCF loaded event:', event.detail);

      if (event.detail && event.detail.layers) {
        const layers = generateEntitiesFromLayers(event.detail.layers);
        console.log('Available layers:', layers);

        // Generate entities for all layers
        const newEntities = layers.map((layer, idx) => ({
          entity: `light.layer_${layer.index}`,
          name: layer.name,
          layer: layer.index,
          initialState: layer.isVisible ? 'on' : 'off'
        }));

        // Only update if entities actually changed
        const entitiesChanged = JSON.stringify(entities) !== JSON.stringify(newEntities);
        if (!entitiesChanged && currentXcfUrl === xcfSelect.value) {
          console.log('Entities unchanged, skipping update');
          return;
        }

        entities = newEntities;
        currentXcfUrl = xcfSelect.value;

        // Reset mockHass states for new entities, respecting initial visibility
        mockHass.states = {};
        entities.forEach(entity => {
          mockHass.states[entity.entity] = {
            state: entity.initialState || 'off',
            attributes: {},
            last_changed: '',
            last_updated: ''
          };
        });

        // Recreate controls
        createEntityControls();

        // Update card - this might trigger another load, but the guard above will prevent infinite loop
        card.setConfig({
          type: 'custom:ha-xcfimage-card',
          title: 'Demo XCF Image',
          xcf_url: xcfSelect.value,
          entity_layers: entities.map(e => ({
            entity: e.entity,
            layer: e.layer,
            state_on: 'on'
          })),
          default_visible: [],
        });
        card.hass = mockHass;
      }
    });

    // Create initial entity controls
    createEntityControls();

    // Initialize card after custom element is defined
    customElements.whenDefined('ha-xcfimage-card').then(() => {
      updateCardConfig();
    });

    // === Entity Overlays Demo ===
    const overlayCard = document.getElementById('overlayCard');

    // Mock entities for overlay demo
    const overlayMockHass = {
      states: {
        'light.kitchen': {
          entity_id: 'light.kitchen',
          state: 'on',
          attributes: {
            friendly_name: 'Kitchen Light',
            icon: 'mdi:lightbulb'
          },
          last_changed: '',
          last_updated: ''
        },
        'sensor.temperature': {
          entity_id: 'sensor.temperature',
          state: '22.5',
          attributes: {
            friendly_name: 'Temperature',
            unit_of_measurement: 'Â°C',
            icon: 'mdi:thermometer'
          },
          last_changed: '',
          last_updated: ''
        },
        'switch.fan': {
          entity_id: 'switch.fan',
          state: 'off',
          attributes: {
            friendly_name: 'Fan',
            icon: 'mdi:fan'
          },
          last_changed: '',
          last_updated: ''
        },
      },
      callService: async (domain, service, data) => {
        console.log(`Service called: ${domain}.${service}`, data);
        const entityId = data.entity_id;
        if (overlayMockHass.states[entityId]) {
          if (service === 'turn_on') {
            overlayMockHass.states[entityId].state = 'on';
          } else if (service === 'turn_off') {
            overlayMockHass.states[entityId].state = 'off';
          }
          overlayCard.hass = { ...overlayMockHass };
          updateOverlayControls();
        }
      },
    };

    function updateOverlayControls() {
      const controlsDiv = document.getElementById('overlayEntityControls');
      controlsDiv.innerHTML = '';

      Object.entries(overlayMockHass.states).forEach(([entityId, state]) => {
        const div = document.createElement('div');
        div.className = 'entity-control';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'entity-name';
        nameSpan.textContent = state.attributes.friendly_name || entityId;

        const stateSpan = document.createElement('span');
        stateSpan.className = 'entity-state ' + (state.state === 'on' ? 'on' : 'off');
        stateSpan.textContent = state.state.toUpperCase();

        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-btn';
        toggleBtn.textContent = 'Toggle';
        toggleBtn.onclick = () => {
          const domain = entityId.split('.')[0];
          const newState = state.state === 'on' ? 'off' : 'on';
          const service = newState === 'on' ? 'turn_on' : 'turn_off';
          overlayMockHass.callService(domain, service, { entity_id: entityId });
        };

        div.appendChild(nameSpan);
        div.appendChild(stateSpan);
        div.appendChild(toggleBtn);
        controlsDiv.appendChild(div);
      });
    }

    // Initialize overlay card
    customElements.whenDefined('ha-xcfimage-card').then(() => {
      overlayCard.setConfig({
        type: 'custom:ha-xcfimage-card',
        title: 'Overlay Demo',
        xcf_url: '/example-xcf/multi.xcf',
        entity_overlays: [
          {
            entity: 'light.kitchen',
            layer: 4,  // tl_red - top-left corner
            display_type: 'badge',
          },
          {
            entity: 'sensor.temperature',
            layer: 8,  // shaded - center
            display_type: 'state-badge',
          },
          {
            entity: 'switch.fan',
            layer: 7,  // tr_red - top-right corner
            display_type: 'icon',
          },
        ],
        default_visible: [9], // Show base layer as background
      });
      overlayCard.hass = overlayMockHass;
      updateOverlayControls();
    });
  </script>
</body>
</html>
