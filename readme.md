# xcfreader

Parses files generated by GIMP (.xcf) and exposes a TypeScript/JavaScript API to read metadata, layers and render images.

## Highlights

- **TypeScript source**: source files in `src/` are TypeScript (`.ts`); compiled to `dist/` with `tsc`.
- **Full type safety**: strict TypeScript with types for `Color`, `ColorRGBA`, `XCFParser`, `GimpLayer`, `XCFImage`.
- **Native ESM**: `package.json` sets `type: "module"` and `main` points to `dist/gimpparser.js`.
- **Promise-based API**: `XCFParser.parseFileAsync(path)` returns a `Promise`; examples and tests use `async`/`await`.
- **Examples and tests**: in `src/examples/` and `src/tests/`, runnable with `npm run build` followed by `node dist/examples/*.js`, or use convenience scripts `npm run single|multi|map|text|test`.

## What it does

- Parse a GIMP XCF file and expose image width/height and layer metadata.
- Provide per-layer rendering via a small `XCFImage` wrapper around `pngjs`.
- Support RGB/RGBA raster images (indexed/grayscale/text/path support is limited or TODO).

![CI](https://github.com/andimclean/xcfreader/actions/workflows/ci.yml/badge.svg)
## Quick start

Install dependencies:
## Supported GIMP/XCF Versions

- GIMP 2.10.x and 2.8.x XCF files (RGB/RGBA raster images)
- Indexed, grayscale, text, and path layers: limited or experimental support
- Known limitations: Some advanced layer types, compression schemes, and parasites may not be fully supported. See Troubleshooting below.

```bash
npm install
npm run build
```

npm run single
## More Usage Examples

### Error Handling Example

```typescript
import { XCFParser, XCFParseError } from "./dist/gimpparser.js";

async function main() {
  try {
    const parser = await XCFParser.parseFileAsync("./examples/doesnotexist.xcf");
  } catch (err) {
    if (err instanceof XCFParseError) {
      console.error("Failed to parse XCF:", err.message);
    } else {
      throw err;
    }
  }
}
```

### Edge Case Example: Empty File

```typescript
import { XCFParser } from "./dist/gimpparser.js";
const parser = await XCFParser.parseFileAsync("./examples/empty.xcf");
console.log(parser.width, parser.height); // Should be 0, 0
```
npm run multi
npm run map
npm run text
npm run empty
```

Run tests (auto-builds first):

```bash
npm test
```

Watch mode (continuous TypeScript compilation):

```bash
npm run watch
```

## Usage (programmatic)

Import and use the parser (ESM):

```ts
import { XCFParser } from "./dist/gimpparser.js";

// Using async/await
const parser = await XCFParser.parseFileAsync("./examples/single.xcf");
console.log(parser.width, parser.height);
console.log("layers:", parser.layers.length);
const image = parser.createImage(); // returns an XCFImage with flattened visible layers
await image.writeImage("./examples/output/flattened.png");
## Usage (TypeScript)

```typescript
import { XCFParser } from "./dist/gimpparser.js";

async function main() {
  const parser = await XCFParser.parseFileAsync("./examples/single.xcf");
  const image = parser.createImage();
  await image.writeImage("./examples/output/flattened.png");
}

main();
```

// Or using callbacks (legacy)
XCFParser.parseFile("./examples/single.xcf", (err, parser) => {
## API notes
## Troubleshooting

- If you see "Invalid XCF file ... missing GIMP magic bytes", check your file is a valid GIMP XCF.
- For errors about unsupported layer types, try flattening or exporting as standard RGB in GIMP.
- If output PNG is blank or corrupted, check layer visibility and opacity in GIMP.
- For binary-parser errors, ensure you are using the correct npm version (see package.json).

## Running Benchmarks

Run:

```bash
npm run benchmark
```

This will parse and render example files, reporting timing results. See dist/benchmarks/benchmark.js for details.
- `XCFParser.parseFileAsync(path)` — parse an XCF file asynchronously; returns `Promise<XCFParser>`.
## License

This project is licensed under the MIT License. See LICENSE for details.
- `XCFParser.parseFile(path, callback)` — parse an XCF file with callback (legacy); calls `parseFileAsync` internally.
- `parser.width`, `parser.height` — numeric image dimensions.
- `parser.layers` — array of `GimpLayer` objects. `GimpLayer` exposes `.name`, `.width`, `.height`, `.x`, `.y`, `.isVisible`, `.isGroup`, `.opacity`, and `.parasites`.
- `GimpLayer.makeImage(image?, useOffset?)` — renders the layer into an `XCFImage` instance. If `image` is omitted, returns a new `XCFImage` sized appropriately.
- `parser.createImage()` — returns an `XCFImage` with all visible layers flattened (uses layer offsets).

## About `XCFImage`

`XCFImage` is a thin wrapper around `pngjs` and implements `setAt(x,y,colour)` and `getAt(x,y)` where `colour` is `{red, green, blue, alpha}`. Example usage and tests expect this contract.

## Browser Usage

xcfreader includes browser bundles that can parse XCF files directly in the browser.

### Using ES Modules (recommended)

```html
<script type="module">
  import { XCFParser } from 'xcfreader/browser';
  
  // Parse from file input
  const input = document.querySelector('input[type="file"]');
  input.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    const arrayBuffer = await file.arrayBuffer();
    
    const parser = XCFParser.parseBuffer(arrayBuffer);
    console.log(`Size: ${parser.width}x${parser.height}`);
    console.log(`Layers: ${parser.layers.length}`);
    
    // Render to canvas
    const image = parser.createImage();
    const canvas = document.getElementById('preview');
    canvas.width = parser.width;
    canvas.height = parser.height;
    const ctx = canvas.getContext('2d');
    const imageData = new ImageData(
      image.getPixelData(),
      parser.width,
      parser.height
    );
    ctx.putImageData(imageData, 0, 0);
  });
</script>
```

### Using Script Tag (IIFE)

```html
<script src="node_modules/xcfreader/dist/xcfreader.browser.js"></script>
<script>
  // XCFReader is available globally
  async function parseXCF(file) {
    const arrayBuffer = await file.arrayBuffer();
    const parser = XCFReader.XCFParser.parseBuffer(arrayBuffer);
    return parser;
  }
</script>
```

### Browser API Notes

- Use `XCFParser.parseBuffer(arrayBuffer)` instead of `parseFileAsync()` in browsers
- `XCFImage.getPixelData()` returns a `Uint8ClampedArray` for use with Canvas `ImageData`
- `XCFImage.width` and `XCFImage.height` getters provide dimensions for `ImageData`
- See `examples/browser-demo.html` for a complete working example

## Notes for contributors

- **Edit source in `src/` only**. TypeScript files are compiled to `dist/` by `npm run build`.
- **Do not edit `dist/`** except to inspect compiled output for debugging.
- Full TypeScript strict mode; be explicit with types or use `as any` sparingly.
- Many parsers are built with `binary-parser`; preserve existing assertions and formatters unless fixing a specific format issue.
- Examples and tests use project-relative paths and explicit `.js` import specifiers to ensure Node ESM resolution.

## See also

- `CHANGELOG.md` for recent changes (TypeScript migration, Promise API).
- `.github/copilot-instructions.md` for AI agent guidance on architecture and common edits.
- `examples/` for runnable TypeScript/JS examples.
- `tests/` for automated test suite.
